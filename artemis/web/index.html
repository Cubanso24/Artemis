<!DOCTYPE html>
<html lang="en" data-theme="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Artemis Threat Hunting Platform</title>
    <script src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"></script>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <style>
        :root {
            --bg-primary: #1a1a2e;
            --bg-secondary: #252545;
            --bg-tertiary: #2f2f5f;
            --text-primary: #eee;
            --text-secondary: #ccc;
            --accent-primary: #667eea;
            --accent-secondary: #764ba2;
            --border-color: #333;
            --success: #28a745;
            --warning: #ffc107;
            --danger: #dc3545;
            --info: #17a2b8;
        }

        [data-theme="light"] {
            --bg-primary: #f5f5f5;
            --bg-secondary: #ffffff;
            --bg-tertiary: #e8e8e8;
            --text-primary: #333;
            --text-secondary: #666;
            --border-color: #ddd;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.6;
            transition: background 0.3s, color 0.3s;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 30px 20px;
            margin-bottom: 30px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
        }

        header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        header p {
            opacity: 0.9;
            font-size: 1.1em;
        }

        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 30px;
            border-bottom: 2px solid #333;
        }

        .tab {
            padding: 15px 30px;
            background: #252545;
            border: none;
            color: #eee;
            cursor: pointer;
            font-size: 16px;
            border-radius: 5px 5px 0 0;
            transition: all 0.3s;
        }

        .tab:hover {
            background: #2f2f5f;
        }

        .tab.active {
            background: #667eea;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .card {
            background: #252545;
            border-radius: 10px;
            padding: 25px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        .card h2 {
            margin-bottom: 20px;
            color: #667eea;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .stat-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
        }

        .stat-card h3 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .stat-card p {
            opacity: 0.9;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
        }

        .form-group input,
        .form-group select,
        .form-group textarea {
            width: 100%;
            padding: 12px;
            background: #1a1a2e;
            border: 2px solid #333;
            border-radius: 5px;
            color: #eee;
            font-size: 16px;
        }

        .form-group input:focus,
        .form-group select:focus,
        .form-group textarea:focus {
            outline: none;
            border-color: #667eea;
        }

        .btn {
            padding: 12px 30px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            border-radius: 5px;
            color: white;
            font-size: 16px;
            cursor: pointer;
            transition: transform 0.2s;
        }

        .btn:hover {
            transform: translateY(-2px);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn-secondary {
            background: #333;
        }

        .progress-container {
            background: var(--bg-primary);
            border-radius: 10px;
            padding: 20px;
            margin-top: 20px;
            display: none;
        }

        .progress-container.active {
            display: block;
        }

        .progress-bar {
            height: 30px;
            background: #333;
            border-radius: 15px;
            overflow: hidden;
            margin-bottom: 15px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
            width: 0%;
            transition: width 0.5s;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            font-size: 13px;
        }

        .collection-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 12px;
            margin-top: 15px;
        }

        .collection-stat {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 12px;
            text-align: center;
        }

        .collection-stat .stat-label {
            font-size: 11px;
            text-transform: uppercase;
            opacity: 0.7;
            margin-bottom: 4px;
        }

        .collection-stat .stat-value {
            font-size: 1.4em;
            font-weight: 700;
            color: var(--accent-primary);
        }

        .collection-stat .stat-value.done {
            color: var(--success);
        }

        .query-tracker {
            margin-top: 15px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 8px;
        }

        .query-chip {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            font-size: 13px;
        }

        .query-chip.done {
            border-color: var(--success);
        }

        .query-chip .q-name {
            opacity: 0.8;
        }

        .query-chip .q-count {
            font-weight: 700;
            color: var(--accent-primary);
        }

        .query-chip.done .q-count {
            color: var(--success);
        }

        .btn-danger {
            background: var(--danger);
            padding: 6px 14px;
            font-size: 13px;
        }

        .btn-danger:hover {
            opacity: 0.85;
            transform: translateY(-1px);
        }

        .btn-sm {
            padding: 6px 14px;
            font-size: 13px;
        }

        .map-list {
            list-style: none;
        }

        .map-item {
            background: var(--bg-primary);
            padding: 15px;
            margin-bottom: 10px;
            border-radius: 5px;
            border-left: 4px solid var(--accent-primary);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .map-item.current {
            border-left-color: var(--success);
        }

        .map-item .map-info {
            flex: 1;
        }

        .map-item .map-actions {
            display: flex;
            gap: 8px;
        }

        .hunt-list {
            list-style: none;
        }

        .hunt-item {
            background: #1a1a2e;
            padding: 15px;
            margin-bottom: 10px;
            border-radius: 5px;
            border-left: 4px solid #667eea;
            cursor: pointer;
            transition: all 0.3s;
        }

        .hunt-item:hover {
            background: #252545;
            transform: translateX(5px);
        }

        .hunt-item .hunt-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .hunt-item .hunt-id {
            font-weight: 600;
            color: #667eea;
        }

        .hunt-item .hunt-status {
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 600;
        }

        .status-completed {
            background: #28a745;
        }

        .status-running {
            background: #ffc107;
            color: #000;
        }

        .status-failed {
            background: #dc3545;
        }

        .finding-item {
            background: #1a1a2e;
            padding: 15px;
            margin-bottom: 15px;
            border-radius: 5px;
            border-left: 4px solid;
        }

        .finding-item.severity-critical, .finding-item.severity-CRITICAL {
            border-color: #dc3545;
        }

        .finding-item.severity-high, .finding-item.severity-HIGH {
            border-color: #ff6b35;
        }

        .finding-item.severity-medium, .finding-item.severity-MEDIUM {
            border-color: #ffc107;
        }

        .finding-item.severity-low, .finding-item.severity-LOW {
            border-color: #17a2b8;
        }

        .finding-item.severity-informational {
            border-color: #6c757d;
        }

        .finding-item h4 {
            margin-bottom: 10px;
            color: #667eea;
        }

        .finding-item .confidence {
            display: inline-block;
            padding: 3px 10px;
            background: #333;
            border-radius: 5px;
            font-size: 12px;
            margin-top: 10px;
        }

        .plugin-list {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
        }

        .plugin-card {
            background: #1a1a2e;
            padding: 20px;
            border-radius: 5px;
            border: 2px solid #333;
        }

        .plugin-card h3 {
            color: #667eea;
            margin-bottom: 10px;
        }

        .plugin-card .plugin-status {
            display: inline-block;
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 600;
            margin-top: 10px;
        }

        .plugin-enabled {
            background: #28a745;
        }

        .plugin-disabled {
            background: #666;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.4; }
        }

        #log-output {
            background: #000;
            padding: 15px;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            height: 400px;
            overflow-y: auto;
            color: #0f0;
        }

        .log-line {
            margin-bottom: 5px;
        }

        .log-error {
            color: #dc3545;
        }

        .log-warning {
            color: #ffc107;
        }

        .log-info {
            color: #17a2b8;
        }

        /* Theme toggle button */
        .theme-toggle {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 10px 20px;
            background: var(--bg-secondary);
            border: 2px solid var(--border-color);
            border-radius: 5px;
            cursor: pointer;
            z-index: 1000;
            transition: all 0.3s;
        }

        .theme-toggle:hover {
            background: var(--bg-tertiary);
        }

        /* Network graph container */
        #network-graph {
            width: 100%;
            height: 600px;
            background: var(--bg-secondary);
            border: 2px solid var(--border-color);
            border-radius: 10px;
        }

        .graph-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .graph-legend {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
            margin-top: 20px;
            padding: 15px;
            background: var(--bg-primary);
            border-radius: 5px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 50%;
        }

        /* Search and filter */
        .search-bar {
            width: 100%;
            max-width: 500px;
            padding: 12px 20px;
            background: var(--bg-primary);
            border: 2px solid var(--border-color);
            border-radius: 25px;
            color: var(--text-primary);
            font-size: 16px;
            margin-bottom: 20px;
        }

        .search-bar:focus {
            outline: none;
            border-color: var(--accent-primary);
        }

        .filter-buttons {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .filter-btn {
            padding: 8px 16px;
            background: var(--bg-secondary);
            border: 2px solid var(--border-color);
            border-radius: 20px;
            color: var(--text-primary);
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s;
        }

        .filter-btn:hover {
            background: var(--bg-tertiary);
        }

        .filter-btn.active {
            background: var(--accent-primary);
            border-color: var(--accent-primary);
        }

        /* Copy button */
        .copy-btn {
            display: inline-block;
            padding: 5px 10px;
            margin-left: 10px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s;
        }

        .copy-btn:hover {
            background: var(--accent-primary);
        }

        .copy-btn.copied {
            background: var(--success);
        }

        /* Template selector */
        .template-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        /* Keyboard shortcuts overlay */
        .shortcuts-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }

        .shortcuts-overlay.show {
            display: flex;
        }

        .shortcuts-content {
            background: var(--bg-secondary);
            padding: 30px;
            border-radius: 10px;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
        }

        .shortcut-list {
            list-style: none;
            margin-top: 20px;
        }

        .shortcut-item {
            display: flex;
            justify-content: space-between;
            padding: 10px;
            margin-bottom: 5px;
            background: var(--bg-primary);
            border-radius: 5px;
        }

        .shortcut-key {
            display: inline-block;
            padding: 3px 8px;
            background: var(--bg-tertiary);
            border-radius: 3px;
            font-family: monospace;
            font-weight: bold;
        }

        /* Mobile responsive */
        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }

            header h1 {
                font-size: 1.8em;
            }

            .stats {
                grid-template-columns: repeat(2, 1fr);
            }

            .tabs {
                flex-wrap: wrap;
            }

            .tab {
                padding: 10px 15px;
                font-size: 14px;
            }

            #network-graph {
                height: 400px;
            }

            .theme-toggle {
                top: 10px;
                right: 10px;
                padding: 8px 15px;
                font-size: 14px;
            }

            .graph-controls, .filter-buttons {
                flex-direction: column;
            }

            .graph-controls button, .filter-btn {
                width: 100%;
            }
        }

        @media (max-width: 480px) {
            header h1 {
                font-size: 1.5em;
            }

            .stats {
                grid-template-columns: 1fr;
            }

            .stat-card h3 {
                font-size: 2em;
            }
        }

        /* Update existing card styles to use variables */
        .card {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
        }

        .hunt-item, .plugin-card, .finding-item {
            background: var(--bg-primary);
        }

        .form-group input,
        .form-group select,
        .form-group textarea {
            background: var(--bg-primary);
            border-color: var(--border-color);
            color: var(--text-primary);
        }

        .tab {
            background: var(--bg-secondary);
            color: var(--text-primary);
        }

        .tab:hover {
            background: var(--bg-tertiary);
        }

        /* Sigma Rules */
        .sigma-rule-item {
            background: var(--bg-primary);
            padding: 15px;
            margin-bottom: 10px;
            border-radius: 5px;
            border-left: 4px solid var(--accent-primary);
        }

        .sigma-rule-item.level-critical { border-left-color: #dc3545; }
        .sigma-rule-item.level-high { border-left-color: #ff6b35; }
        .sigma-rule-item.level-medium { border-left-color: #ffc107; }
        .sigma-rule-item.level-low { border-left-color: #17a2b8; }
        .sigma-rule-item.level-informational { border-left-color: #6c757d; }

        .sigma-match-item {
            background: var(--bg-primary);
            padding: 15px;
            margin-bottom: 12px;
            border-radius: 5px;
            border-left: 4px solid #dc3545;
        }

        .sigma-match-item.level-critical { border-left-color: #dc3545; }
        .sigma-match-item.level-high { border-left-color: #ff6b35; }
        .sigma-match-item.level-medium { border-left-color: #ffc107; }
        .sigma-match-item.level-low { border-left-color: #17a2b8; }
        .sigma-match-item.level-informational { border-left-color: #6c757d; }

        .sigma-badge {
            display: inline-block;
            padding: 3px 10px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            margin-right: 6px;
        }

        .sigma-badge.critical { background: #dc3545; }
        .sigma-badge.high { background: #ff6b35; }
        .sigma-badge.medium { background: #ffc107; color: #000; }
        .sigma-badge.low { background: #17a2b8; }
        .sigma-badge.informational { background: #6c757d; }

        .sigma-tag {
            display: inline-block;
            padding: 2px 8px;
            background: var(--bg-tertiary);
            border-radius: 4px;
            font-size: 11px;
            margin: 2px;
        }

        .sample-event {
            background: #000;
            color: #0f0;
            padding: 10px;
            border-radius: 5px;
            font-family: monospace;
            font-size: 12px;
            overflow-x: auto;
            max-height: 200px;
            overflow-y: auto;
            margin-top: 8px;
        }

        /* GeoIP Map */
        #geoip-map {
            width: 100%;
            height: 500px;
            border-radius: 10px;
            border: 2px solid var(--border-color);
            z-index: 1;
        }

        .country-bar {
            display: flex;
            align-items: center;
            margin-bottom: 6px;
        }

        .country-bar .bar-label {
            width: 140px;
            font-size: 13px;
            flex-shrink: 0;
        }

        .country-bar .bar-fill {
            height: 20px;
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
            border-radius: 3px;
            transition: width 0.3s;
            min-width: 2px;
        }

        .country-bar .bar-count {
            margin-left: 8px;
            font-size: 12px;
            opacity: 0.8;
            flex-shrink: 0;
        }

        .geoip-top-talker {
            display: flex;
            justify-content: space-between;
            padding: 8px 12px;
            background: var(--bg-primary);
            border-radius: 5px;
            margin-bottom: 6px;
            font-size: 13px;
        }
    </style>
</head>
<body>
    <!-- Theme Toggle -->
    <button class="theme-toggle" onclick="toggleTheme()" title="Toggle dark/light mode (T)">
        <span id="theme-icon">üåô</span>
    </button>

    <!-- Keyboard Shortcuts Overlay -->
    <div class="shortcuts-overlay" id="shortcuts-overlay" onclick="if(event.target === this) toggleShortcuts()">
        <div class="shortcuts-content">
            <h2>Keyboard Shortcuts</h2>
            <ul class="shortcut-list">
                <li class="shortcut-item">
                    <span>Go to Dashboard</span>
                    <span class="shortcut-key">D</span>
                </li>
                <li class="shortcut-item">
                    <span>New Hunt</span>
                    <span class="shortcut-key">N</span>
                </li>
                <li class="shortcut-item">
                    <span>Hunt History</span>
                    <span class="shortcut-key">H</span>
                </li>
                <li class="shortcut-item">
                    <span>Network Graph</span>
                    <span class="shortcut-key">G</span>
                </li>
                <li class="shortcut-item">
                    <span>Network Maps</span>
                    <span class="shortcut-key">M</span>
                </li>
                <li class="shortcut-item">
                    <span>Plugins</span>
                    <span class="shortcut-key">P</span>
                </li>
                <li class="shortcut-item">
                    <span>Live Logs</span>
                    <span class="shortcut-key">L</span>
                </li>
                <li class="shortcut-item">
                    <span>Toggle Theme</span>
                    <span class="shortcut-key">T</span>
                </li>
                <li class="shortcut-item">
                    <span>Show Shortcuts</span>
                    <span class="shortcut-key">?</span>
                </li>
                <li class="shortcut-item">
                    <span>Close Overlay</span>
                    <span class="shortcut-key">ESC</span>
                </li>
            </ul>
            <button class="btn" onclick="toggleShortcuts()" style="margin-top: 20px; width: 100%;">Close</button>
        </div>
    </div>

    <div class="container">
        <header>
            <h1>üèπ Artemis Threat Hunting Platform</h1>
            <p>Multi-Agent Network Security Analysis & Threat Detection</p>
        </header>

        <div class="stats">
            <div class="stat-card">
                <h3 id="stat-hunts">0</h3>
                <p>Total Hunts</p>
            </div>
            <div class="stat-card">
                <h3 id="stat-findings">0</h3>
                <p>Total Findings</p>
            </div>
            <div class="stat-card">
                <h3 id="stat-active">0</h3>
                <p>Active Hunts</p>
            </div>
            <div class="stat-card">
                <h3 id="stat-plugins">0</h3>
                <p>Plugins Enabled</p>
            </div>
        </div>

        <div class="tabs">
            <button class="tab active" onclick="showTab('dashboard')">Dashboard</button>
            <button class="tab" onclick="showTab('new-hunt')">New Hunt</button>
            <button class="tab" onclick="showTab('history')">Hunt History</button>
            <button class="tab" onclick="showTab('sigma-tab')">Sigma Rules</button>
            <button class="tab" onclick="showTab('geoip-tab')">GeoIP Map</button>
            <button class="tab" onclick="showTab('network-graph-tab')">Network Graph</button>
            <button class="tab" onclick="showTab('network-maps-tab')">Network Maps</button>
            <button class="tab" onclick="showTab('plugins')">Plugins</button>
            <button class="tab" onclick="showTab('logs')">Live Logs</button>
        </div>

        <!-- Dashboard Tab -->
        <div id="dashboard" class="tab-content active">
            <div class="card">
                <h2>Quick Actions</h2>
                <button class="btn" onclick="quickHunt('-1h')">Hunt Last Hour</button>
                <button class="btn" onclick="quickHunt('-24h')">Hunt Last 24 Hours</button>
                <button class="btn" onclick="quickHunt('-7d')">Hunt Last Week</button>
            </div>

            <div class="card">
                <h2>Recent Hunts</h2>
                <ul id="recent-hunts" class="hunt-list">
                    <li>Loading...</li>
                </ul>
            </div>
        </div>

        <!-- New Hunt Tab -->
        <div id="new-hunt" class="tab-content">
            <div class="card">
                <h2>Configure New Threat Hunt</h2>

                <!-- Hunt Templates -->
                <div class="template-controls">
                    <select id="hunt-template" onchange="loadHuntTemplate()">
                        <option value="">-- Load Hunt Template --</option>
                    </select>
                    <button type="button" class="btn btn-secondary" onclick="saveHuntTemplate()">Save as Template</button>
                    <button type="button" class="btn btn-secondary" onclick="deleteHuntTemplate()">Delete Template</button>
                </div>

                <form id="hunt-form">
                    <div class="form-group">
                        <label for="time-range">Time Range</label>
                        <select id="time-range">
                            <option value="-1h">Last Hour</option>
                            <option value="-4h">Last 4 Hours</option>
                            <option value="-12h">Last 12 Hours</option>
                            <option value="-24h">Last 24 Hours</option>
                            <option value="-7d">Last 7 Days</option>
                            <option value="-30d">Last 30 Days</option>
                        </select>
                    </div>

                    <div class="form-group">
                        <label for="hunt-mode">Hunt Mode</label>
                        <select id="hunt-mode">
                            <option value="PARALLEL">Parallel (Fast - all agents at once)</option>
                            <option value="ADAPTIVE">Adaptive (Smart - progressive deployment)</option>
                            <option value="SEQUENTIAL">Sequential (Thorough - one by one)</option>
                        </select>
                    </div>

                    <div class="form-group">
                        <label for="description">Description (optional)</label>
                        <textarea id="description" rows="3" placeholder="e.g., Investigating suspicious activity on subnet 10.0.1.0/24"></textarea>
                    </div>

                    <button type="submit" class="btn">Start Hunt</button>
                </form>

                <div id="progress" class="progress-container">
                    <h3 id="progress-title">Hunt in Progress</h3>
                    <div class="progress-bar">
                        <div id="progress-fill" class="progress-fill">0%</div>
                    </div>
                    <p id="progress-message">Initializing...</p>

                    <div id="collection-detail" style="display:none;">
                        <div class="collection-stats">
                            <div class="collection-stat">
                                <div class="stat-label">Total Events</div>
                                <div class="stat-value" id="coll-total-events">0</div>
                            </div>
                            <div class="collection-stat">
                                <div class="stat-label">Queries Done</div>
                                <div class="stat-value" id="coll-queries-done">0 / 8</div>
                            </div>
                            <div class="collection-stat">
                                <div class="stat-label">Window</div>
                                <div class="stat-value" id="coll-window">-</div>
                            </div>
                            <div class="collection-stat">
                                <div class="stat-label">Elapsed</div>
                                <div class="stat-value" id="coll-elapsed">0s</div>
                            </div>
                        </div>

                        <div class="query-tracker" id="query-tracker"></div>
                    </div>
                </div>
            </div>
        </div>

        <!-- History Tab -->
        <div id="history" class="tab-content">
            <div class="card">
                <h2>Hunt History</h2>

                <!-- Search Bar -->
                <input type="text" class="search-bar" id="history-search"
                       placeholder="Search hunts by ID, description, or findings..."
                       oninput="filterHunts()">

                <!-- Filter Buttons -->
                <div class="filter-buttons">
                    <button class="filter-btn active" data-filter="all" onclick="filterBySeverity(this, 'all')">All</button>
                    <button class="filter-btn" data-filter="critical" onclick="filterBySeverity(this, 'critical')">Critical</button>
                    <button class="filter-btn" data-filter="high" onclick="filterBySeverity(this, 'high')">High</button>
                    <button class="filter-btn" data-filter="medium" onclick="filterBySeverity(this, 'medium')">Medium</button>
                    <button class="filter-btn" data-filter="low" onclick="filterBySeverity(this, 'low')">Low</button>
                    <button class="filter-btn" data-filter="clean" onclick="filterBySeverity(this, 'clean')">Clean (0 findings)</button>
                </div>

                <ul id="hunt-history" class="hunt-list">
                    <li>Loading...</li>
                </ul>
            </div>

            <div id="hunt-details" class="card" style="display:none;">
                <h2>Hunt Details</h2>
                <div id="hunt-details-content"></div>
            </div>
        </div>

        <!-- Sigma Rules Tab -->
        <div id="sigma-tab" class="tab-content">
            <div class="card">
                <h2>Sigma Detection Rules</h2>
                <p style="margin-bottom:15px; opacity:0.8;">
                    Sigma rules are automatically matched against collected hunt data. Place <code>.yml</code> rule files in the <code>sigma_rules/</code> directory.
                </p>

                <div style="display:flex; gap:10px; margin-bottom:20px; flex-wrap:wrap;">
                    <button class="btn" onclick="loadSigmaRules()">Refresh Rules</button>
                    <button class="btn btn-secondary" onclick="reloadSigmaRules()">Reload from Disk</button>
                    <button class="btn btn-secondary" onclick="loadSigmaResults()">View Latest Results</button>
                </div>

                <div id="sigma-stats" class="stats" style="margin-bottom:20px;">
                    <div class="stat-card" style="background: var(--bg-tertiary);">
                        <h3 id="sigma-stat-rules">0</h3>
                        <p>Loaded Rules</p>
                    </div>
                    <div class="stat-card" style="background: var(--bg-tertiary);">
                        <h3 id="sigma-stat-matches">0</h3>
                        <p>Last Scan Matches</p>
                    </div>
                    <div class="stat-card" style="background: var(--bg-tertiary);">
                        <h3 id="sigma-stat-critical">0</h3>
                        <p>Critical/High Hits</p>
                    </div>
                </div>

                <h3 style="margin-bottom:10px;">Loaded Rules</h3>
                <div style="margin-bottom:10px; display:flex; gap:10px; flex-wrap:wrap;">
                    <input type="text" id="sigma-search" placeholder="Filter rules..." oninput="filterSigmaRules()" style="padding:8px 12px; border-radius:5px; border:1px solid #444; background:#1a1a2e; color:#eee; flex:1; min-width:200px;">
                    <select id="sigma-level-filter" onchange="filterSigmaRules()" style="padding:8px 12px; border-radius:5px; border:1px solid #444; background:#1a1a2e; color:#eee;">
                        <option value="">All Levels</option>
                        <option value="critical">Critical</option>
                        <option value="high">High</option>
                        <option value="medium">Medium</option>
                        <option value="low">Low</option>
                        <option value="informational">Informational</option>
                    </select>
                </div>
                <div id="sigma-rules-list">
                    <p style="opacity:0.7;">Enable the Sigma Engine plugin to load rules.</p>
                </div>
            </div>

            <div id="sigma-results-card" class="card" style="display:none;">
                <h2>Sigma Scan Results</h2>
                <p id="sigma-results-meta" style="margin-bottom:15px; opacity:0.8;"></p>
                <div id="sigma-results-list"></div>
            </div>
        </div>

        <!-- GeoIP Map Tab -->
        <div id="geoip-tab" class="tab-content">
            <div class="card">
                <h2>Geographic Connection Map</h2>
                <p style="margin-bottom:15px; opacity:0.8;">
                    External IP addresses from hunt data mapped to geographic locations. Enable the GeoIP Mapper plugin and run a hunt to populate.
                </p>

                <div style="display:flex; gap:10px; margin-bottom:20px; flex-wrap:wrap;">
                    <button class="btn" onclick="loadGeoIPMap()">Refresh Map</button>
                </div>

                <div id="geoip-map"></div>

                <div style="display:grid; grid-template-columns:1fr 1fr; gap:20px; margin-top:20px;">
                    <div>
                        <h3 style="margin-bottom:10px;">Connections by Country</h3>
                        <div id="geoip-country-chart"></div>
                    </div>
                    <div>
                        <h3 style="margin-bottom:10px;">Top External Talkers</h3>
                        <div id="geoip-top-talkers"></div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Network Graph Tab -->
        <div id="network-graph-tab" class="tab-content">
            <div class="card">
                <h2>Network Topology Graph</h2>

                <div class="graph-controls">
                    <span id="graph-live-badge" style="display:none; background:#f44336; color:#fff; padding:4px 12px; border-radius:12px; font-size:12px; font-weight:600; animation: pulse 1.5s infinite; margin-right:10px;">LIVE</span>
                    <input type="text" id="graph-search" placeholder="Search IP address..." onkeydown="if(event.key==='Enter') searchGraphNode()" style="padding:8px 12px; border-radius:5px; border:1px solid #444; background:#1a1a2e; color:#eee; width:200px;">
                    <button class="btn" onclick="searchGraphNode()">Find</button>
                    <button class="btn" onclick="loadNetworkGraph()">Refresh Graph</button>
                    <button class="btn btn-secondary" onclick="resetGraphZoom()">Reset Zoom</button>
                    <button class="btn btn-secondary" onclick="exportGraphImage()">Export as PNG</button>
                    <button class="btn" onclick="profileDevices()" id="profile-btn" style="background:#9C27B0;">Profile Devices</button>
                    <select id="graph-layout" onchange="changeGraphLayout()">
                        <option value="forceAtlas2Based">Force Atlas</option>
                        <option value="barnesHut">Barnes Hut</option>
                        <option value="hierarchical">Hierarchical</option>
                    </select>
                    <select id="profile-time-range" style="padding:8px 12px; border-radius:5px; border:1px solid #444; background:#1a1a2e; color:#eee;">
                        <option value="-1h">Last 1h</option>
                        <option value="-4h">Last 4h</option>
                        <option value="-24h" selected>Last 24h</option>
                        <option value="-7d">Last 7d</option>
                    </select>
                </div>

                <div id="network-graph"></div>

                <div class="graph-legend" id="graph-legend">
                    <div class="legend-item"><div class="legend-color" style="background: #4CAF50;"></div><span>Internal</span></div>
                    <div class="legend-item"><div class="legend-color" style="background: #f44336;"></div><span>External</span></div>
                    <div class="legend-item"><div class="legend-color" style="background: #FFC107;"></div><span>Server</span></div>
                    <div class="legend-item"><div class="legend-color" style="background: #E91E63;"></div><span>DC</span></div>
                    <div class="legend-item"><div class="legend-color" style="background: #00BCD4;"></div><span>DNS</span></div>
                    <div class="legend-item"><div class="legend-color" style="background: #FF5722;"></div><span>Web</span></div>
                    <div class="legend-item"><div class="legend-color" style="background: #9C27B0;"></div><span>Database</span></div>
                    <div class="legend-item"><div class="legend-color" style="background: #3F51B5;"></div><span>File/Mail</span></div>
                    <div class="legend-item"><div class="legend-color" style="background: #607D8B;"></div><span>Workstation</span></div>
                </div>
                <div id="profile-status" style="display:none; margin-top:10px; padding:10px; background:var(--bg-tertiary); border-radius:5px;"></div>

                <div class="card" style="margin-top: 20px;">
                    <h3>Network Summary</h3>
                    <div id="network-summary">
                        <p>Loading network statistics...</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- Network Maps Tab -->
        <div id="network-maps-tab" class="tab-content">
            <div class="card">
                <h2>Network Map Management</h2>
                <p style="margin-bottom:15px; opacity:0.8;">
                    Each hunt adds data to the current network map. Save snapshots before resetting, or load old maps to review.
                </p>

                <div style="display:flex; gap:10px; margin-bottom:20px; flex-wrap:wrap;">
                    <button class="btn" onclick="saveMapSnapshot()">Save Snapshot</button>
                    <button class="btn btn-danger" onclick="resetNetworkMap()">Reset Map (Start Fresh)</button>
                    <button class="btn btn-secondary" onclick="loadNetworkMaps()">Refresh List</button>
                </div>

                <ul id="network-maps-list" class="map-list">
                    <li>Loading...</li>
                </ul>
            </div>
        </div>

        <!-- Plugins Tab -->
        <div id="plugins" class="tab-content">
            <div class="card">
                <h2>Available Plugins</h2>
                <div id="plugin-list" class="plugin-list">
                    <p>Loading plugins...</p>
                </div>
            </div>
        </div>

        <!-- Logs Tab -->
        <div id="logs" class="tab-content">
            <div class="card">
                <h2>Live System Logs</h2>
                <div id="log-output"></div>
            </div>
        </div>
    </div>

    <script>
        // WebSocket connection
        let ws = null;
        let currentHuntId = null;
        let networkGraph = null;
        let networkGraphData = null;  // Store current graph data for search
        let geoipMap = null;
        let allHunts = [];  // Store all hunts for filtering
        let graphLiveInterval = null;  // Live graph refresh during hunts

        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            connectWebSocket();
            loadStats();
            loadRecentHunts();
            loadPlugins();
            loadHuntTemplates();
            loadNetworkMaps();
            initializeTheme();
            checkActiveHunts();

            // Restore current hunt ID from localStorage
            currentHuntId = localStorage.getItem('currentHuntId') || null;

            // Setup form handler
            document.getElementById('hunt-form').addEventListener('submit', startHunt);

            // Refresh data every 10 seconds
            setInterval(loadStats, 10000);
            setInterval(loadRecentHunts, 10000);

            // Setup keyboard shortcuts
            document.addEventListener('keydown', handleKeyboardShortcut);
        });

        // Theme management
        function initializeTheme() {
            const savedTheme = localStorage.getItem('theme') || 'dark';
            document.documentElement.setAttribute('data-theme', savedTheme);
            updateThemeIcon(savedTheme);
        }

        function toggleTheme() {
            const html = document.documentElement;
            const currentTheme = html.getAttribute('data-theme');
            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
            html.setAttribute('data-theme', newTheme);
            localStorage.setItem('theme', newTheme);
            updateThemeIcon(newTheme);
        }

        function updateThemeIcon(theme) {
            document.getElementById('theme-icon').textContent = theme === 'dark' ? 'üåô' : '‚òÄÔ∏è';
        }

        // Keyboard shortcuts
        function handleKeyboardShortcut(e) {
            // Ignore if typing in input/textarea
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
                return;
            }

            switch(e.key.toLowerCase()) {
                case 'd':
                    showTabByName('dashboard');
                    break;
                case 'n':
                    showTabByName('new-hunt');
                    break;
                case 'h':
                    showTabByName('history');
                    break;
                case 's':
                    showTabByName('sigma-tab');
                    loadSigmaRules();
                    break;
                case 'g':
                    showTabByName('geoip-tab');
                    loadGeoIPMap();
                    break;
                case 'm':
                    showTabByName('network-maps-tab');
                    loadNetworkMaps();
                    break;
                case 'p':
                    showTabByName('plugins');
                    break;
                case 'l':
                    showTabByName('logs');
                    break;
                case 't':
                    toggleTheme();
                    break;
                case '?':
                    toggleShortcuts();
                    break;
                case 'escape':
                    toggleShortcuts(false);
                    break;
            }
        }

        function toggleShortcuts(show) {
            const overlay = document.getElementById('shortcuts-overlay');
            if (show === false) {
                overlay.classList.remove('show');
            } else {
                overlay.classList.toggle('show');
            }
        }

        function showTabByName(tabName) {
            // Hide all tabs
            document.querySelectorAll('.tab-content').forEach(tab => {
                tab.classList.remove('active');
            });

            // Remove active from all tab buttons
            document.querySelectorAll('.tab').forEach(btn => {
                btn.classList.remove('active');
            });

            // Show selected tab
            document.getElementById(tabName).classList.add('active');

            // Highlight active button
            const tabs = document.querySelectorAll('.tab');
            tabs.forEach(tab => {
                if (tab.textContent.toLowerCase().includes(tabName.split('-')[0])) {
                    tab.classList.add('active');
                }
            });
        }

        // Hunt templates
        function loadHuntTemplates() {
            const templates = JSON.parse(localStorage.getItem('huntTemplates') || '{}');
            const select = document.getElementById('hunt-template');
            select.innerHTML = '<option value="">-- Load Hunt Template --</option>';

            Object.keys(templates).forEach(name => {
                const option = document.createElement('option');
                option.value = name;
                option.textContent = name;
                select.appendChild(option);
            });
        }

        function saveHuntTemplate() {
            const name = prompt('Enter template name:');
            if (!name) return;

            const template = {
                timeRange: document.getElementById('time-range').value,
                mode: document.getElementById('hunt-mode').value,
                description: document.getElementById('description').value
            };

            const templates = JSON.parse(localStorage.getItem('huntTemplates') || '{}');
            templates[name] = template;
            localStorage.setItem('huntTemplates', JSON.stringify(templates));

            loadHuntTemplates();
            addLog(`Saved template: ${name}`, 'info');
        }

        function loadHuntTemplate() {
            const select = document.getElementById('hunt-template');
            const name = select.value;
            if (!name) return;

            const templates = JSON.parse(localStorage.getItem('huntTemplates') || '{}');
            const template = templates[name];

            if (template) {
                document.getElementById('time-range').value = template.timeRange;
                document.getElementById('hunt-mode').value = template.mode;
                document.getElementById('description').value = template.description;
                addLog(`Loaded template: ${name}`, 'info');
            }
        }

        function deleteHuntTemplate() {
            const select = document.getElementById('hunt-template');
            const name = select.value;
            if (!name) {
                alert('Please select a template to delete');
                return;
            }

            if (!confirm(`Delete template "${name}"?`)) return;

            const templates = JSON.parse(localStorage.getItem('huntTemplates') || '{}');
            delete templates[name];
            localStorage.setItem('huntTemplates', JSON.stringify(templates));

            loadHuntTemplates();
            addLog(`Deleted template: ${name}`, 'info');
        }

        // Copy to clipboard
        function copyToClipboard(text, button) {
            navigator.clipboard.writeText(text).then(() => {
                if (button) {
                    const originalText = button.textContent;
                    button.textContent = '‚úì Copied!';
                    button.classList.add('copied');
                    setTimeout(() => {
                        button.textContent = originalText;
                        button.classList.remove('copied');
                    }, 2000);
                }
                addLog(`Copied to clipboard: ${text}`, 'info');
            }).catch(err => {
                console.error('Failed to copy:', err);
            });
        }

        // Search and filter hunts
        function filterHunts() {
            const searchTerm = document.getElementById('history-search').value.toLowerCase();
            const huntItems = document.querySelectorAll('#hunt-history .hunt-item');

            huntItems.forEach(item => {
                const text = item.textContent.toLowerCase();
                if (text.includes(searchTerm)) {
                    item.style.display = '';
                } else {
                    item.style.display = 'none';
                }
            });
        }

        function filterBySeverity(button, severity) {
            // Update active button
            document.querySelectorAll('.filter-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            button.classList.add('active');

            const huntItems = document.querySelectorAll('#hunt-history .hunt-item');

            huntItems.forEach(item => {
                if (severity === 'all') {
                    item.style.display = '';
                } else if (severity === 'clean') {
                    const findingsText = item.querySelector('div').textContent;
                    const findings = parseInt(findingsText.match(/(\d+) findings/)?.[1] || '0');
                    item.style.display = findings === 0 ? '' : 'none';
                } else {
                    // Filter by severity would require hunt data - simplified for now
                    item.style.display = '';
                }
            });
        }

        function connectWebSocket() {
            ws = new WebSocket(`ws://${window.location.host}/ws`);

            ws.onopen = () => {
                addLog('Connected to Artemis server', 'info');
            };

            ws.onmessage = (event) => {
                const data = JSON.parse(event.data);

                // Handle different message types
                if (data.type === 'server_log') {
                    // Server-side log message
                    addLog(data.message, data.log_type);
                } else {
                    // Progress update message
                    handleProgress(data);
                }
            };

            ws.onclose = () => {
                addLog('Disconnected from server. Reconnecting...', 'warning');
                setTimeout(connectWebSocket, 3000);
            };
        }

        async function checkActiveHunts() {
            try {
                const response = await fetch('/api/hunts/active');
                const active = await response.json();

                if (active.length > 0) {
                    const hunt = active[0];
                    currentHuntId = hunt.hunt_id;
                    localStorage.setItem('currentHuntId', hunt.hunt_id);

                    // Show progress container and restore last known state
                    document.getElementById('progress').classList.add('active');

                    if (hunt.last_progress) {
                        handleProgress(hunt.last_progress);
                    } else {
                        document.getElementById('progress-message').textContent =
                            `Hunt ${hunt.hunt_id} is running (${hunt.progress}%)...`;
                        document.getElementById('progress-fill').style.width = `${hunt.progress}%`;
                        document.getElementById('progress-fill').textContent = `${hunt.progress}%`;
                    }

                    addLog(`Reconnected to active hunt: ${hunt.hunt_id}`, 'info');
                }
            } catch (error) {
                console.error('Error checking active hunts:', error);
            }
        }

        async function loadStats() {
            try {
                const response = await fetch('/api/status');
                const data = await response.json();

                document.getElementById('stat-active').textContent = data.active_hunts;
                document.getElementById('stat-plugins').textContent =
                    data.plugins.filter(p => p.enabled).length;

                // Load hunt count
                const hunts = await fetch('/api/hunts?limit=1000');
                const huntsData = await hunts.json();
                document.getElementById('stat-hunts').textContent = huntsData.length;

                const totalFindings = huntsData.reduce((sum, h) => sum + (h.total_findings || 0), 0);
                document.getElementById('stat-findings').textContent = totalFindings;

            } catch (error) {
                console.error('Error loading stats:', error);
            }
        }

        async function loadRecentHunts() {
            try {
                const response = await fetch('/api/hunts?limit=50');
                const hunts = await response.json();
                allHunts = hunts;

                // Dashboard: show last 5
                const recentList = document.getElementById('recent-hunts');
                recentList.innerHTML = '';
                if (hunts.length === 0) {
                    recentList.innerHTML = '<li>No hunts yet. Start your first hunt!</li>';
                } else {
                    hunts.slice(0, 5).forEach(hunt => {
                        recentList.appendChild(createHuntItem(hunt, false));
                    });
                }

                // History tab: show all with delete buttons
                const historyList = document.getElementById('hunt-history');
                historyList.innerHTML = '';
                if (hunts.length === 0) {
                    historyList.innerHTML = '<li>No hunts yet.</li>';
                } else {
                    hunts.forEach(hunt => {
                        historyList.appendChild(createHuntItem(hunt, true));
                    });
                }

            } catch (error) {
                console.error('Error loading hunts:', error);
            }
        }

        function createHuntItem(hunt, showDelete) {
            const li = document.createElement('li');
            li.className = 'hunt-item';
            li.setAttribute('data-hunt-id', hunt.hunt_id);

            li.innerHTML = `
                <div class="hunt-header">
                    <span class="hunt-id" style="cursor:pointer;" onclick="viewHuntDetails('${hunt.hunt_id}')">${hunt.hunt_id}</span>
                    <div style="display:flex; gap:8px; align-items:center;">
                        <span class="hunt-status status-${hunt.status}">${hunt.status}</span>
                        ${showDelete && hunt.status !== 'running' ? `<button class="btn btn-danger btn-sm" onclick="event.stopPropagation(); deleteHunt('${hunt.hunt_id}')">Delete</button>` : ''}
                    </div>
                </div>
                <div style="cursor:pointer;" onclick="viewHuntDetails('${hunt.hunt_id}')">
                    <strong>${hunt.total_findings || 0}</strong> findings |
                    Confidence: <strong>${(hunt.overall_confidence || 0).toFixed(2)}</strong> |
                    ${hunt.time_range} |
                    ${new Date(hunt.start_time).toLocaleString()}
                </div>
                ${hunt.description ? `<div style="margin-top:5px;opacity:0.8;">${hunt.description}</div>` : ''}
            `;

            return li;
        }

        async function deleteHunt(huntId) {
            if (!confirm(`Delete hunt "${huntId}" and all its findings? This cannot be undone.`)) return;

            try {
                const response = await fetch(`/api/hunts/${huntId}`, { method: 'DELETE' });
                const result = await response.json();

                if (result.error) {
                    alert(result.error);
                    return;
                }

                addLog(`Deleted hunt: ${huntId}`, 'info');
                loadRecentHunts();
                loadStats();

                // Hide details panel if we deleted the currently viewed hunt
                document.getElementById('hunt-details').style.display = 'none';

            } catch (error) {
                console.error('Error deleting hunt:', error);
                addLog(`Error deleting hunt: ${error.message}`, 'error');
            }
        }

        async function viewHuntDetails(huntId) {
            try {
                const response = await fetch(`/api/hunts/${huntId}`);
                const hunt = await response.json();

                const detailsDiv = document.getElementById('hunt-details');
                const contentDiv = document.getElementById('hunt-details-content');

                let html = `
                    <h3>${hunt.hunt_id}
                        <button class="copy-btn" onclick="copyToClipboard('${hunt.hunt_id}', this)">üìã Copy ID</button>
                    </h3>
                    <p><strong>Time Range:</strong> ${hunt.time_range}</p>
                    <p><strong>Mode:</strong> ${hunt.mode}</p>
                    <p><strong>Status:</strong> ${hunt.status}</p>
                    <p><strong>Total Findings:</strong> ${hunt.total_findings || 0}</p>
                    <p><strong>Overall Confidence:</strong> ${(hunt.overall_confidence || 0).toFixed(2)}</p>
                    ${hunt.description ? `<p><strong>Description:</strong> ${hunt.description}</p>` : ''}
                    <hr style="margin:20px 0;">
                    <h3>Findings</h3>
                `;

                if (hunt.findings && hunt.findings.length > 0) {
                    // Check for sigma findings
                    const sigmaFindings = hunt.findings.filter(f => f.agent_name === 'sigma_engine');
                    const agentFindings = hunt.findings.filter(f => f.agent_name !== 'sigma_engine');

                    if (sigmaFindings.length > 0) {
                        html += `<div style="background:var(--bg-tertiary); padding:12px 16px; border-radius:5px; margin-bottom:15px; border-left:4px solid #ffc107;">
                            <strong>${sigmaFindings.length} Sigma rule match${sigmaFindings.length > 1 ? 'es' : ''}</strong> detected.
                            <button class="btn btn-secondary" style="margin-left:10px; padding:4px 12px; font-size:12px;"
                                onclick="showTab('sigma-tab'); loadSigmaResults();">View Full Sigma Results</button>
                        </div>`;
                    }

                    hunt.findings.forEach(finding => {
                        // Extract IPs from affected assets
                        const assetsWithCopy = finding.affected_assets && finding.affected_assets.length > 0
                            ? finding.affected_assets.map(asset =>
                                `${asset} <button class="copy-btn" onclick="copyToClipboard('${asset}', this)">üìã</button>`
                              ).join(' ')
                            : '';

                        html += `
                            <div class="finding-item severity-${finding.severity || 'low'}">
                                <h4>${finding.title || 'Untitled Finding'}</h4>
                                <p>${finding.description || ''}</p>
                                <p><strong>Agent:</strong> ${finding.agent_name || 'unknown'}</p>
                                ${assetsWithCopy ? `<p><strong>Affected:</strong> ${assetsWithCopy}</p>` : ''}
                                ${finding.mitre_tactics && finding.mitre_tactics.length > 0 ?
                                    `<p><strong>MITRE Tactics:</strong> ${finding.mitre_tactics.join(', ')}</p>` : ''}
                                ${finding.mitre_techniques && finding.mitre_techniques.length > 0 ?
                                    `<p><strong>MITRE Techniques:</strong> ${finding.mitre_techniques.join(', ')}</p>` : ''}
                                <span class="confidence">Confidence: ${(finding.confidence || 0).toFixed(2)}</span>
                            </div>
                        `;
                    });
                } else {
                    html += '<p>No findings - network appears clean!</p>';
                }

                contentDiv.innerHTML = html;
                detailsDiv.style.display = 'block';

                // Switch to history tab
                showTab('history');

            } catch (error) {
                console.error('Error loading hunt details:', error);
                addLog(`Error loading hunt details: ${error.message}`, 'error');
            }
        }

        // Network Graph Functions
        async function loadNetworkGraph(silent = false) {
            try {
                if (!silent) addLog('Loading network topology...', 'info');

                const response = await fetch('/api/network-graph');
                const graphData = await response.json();

                if (graphData.error) {
                    if (!silent) {
                        addLog('Network mapper plugin not enabled', 'warning');
                        document.getElementById('network-graph').innerHTML =
                            '<p style="text-align:center; padding:50px;">Network mapper plugin not enabled. Enable it in the Plugins tab.</p>';
                    }
                    return;
                }

                renderNetworkGraph(graphData);
                if (!silent) loadNetworkSummary();

                if (!silent) {
                    addLog(`Loaded network graph with ${graphData.nodes.length} nodes and ${graphData.edges.length} edges`, 'info');
                }

            } catch (error) {
                if (!silent) {
                    console.error('Error loading network graph:', error);
                    addLog(`Error loading network graph: ${error.message}`, 'error');
                }
            }
        }

        function startLiveGraph() {
            if (graphLiveInterval) return;  // Already running
            graphLiveInterval = setInterval(() => loadNetworkGraph(true), 5000);
            const badge = document.getElementById('graph-live-badge');
            if (badge) badge.style.display = 'inline-block';
        }

        function stopLiveGraph() {
            if (graphLiveInterval) {
                clearInterval(graphLiveInterval);
                graphLiveInterval = null;
            }
            const badge = document.getElementById('graph-live-badge');
            if (badge) badge.style.display = 'none';
            // One final refresh with summary
            loadNetworkGraph(false);
        }

        function renderNetworkGraph(graphData) {
            const container = document.getElementById('network-graph');

            if (!graphData.nodes || graphData.nodes.length === 0) {
                container.innerHTML = '<p style="text-align:center; padding:50px;">No network nodes yet. Run a hunt with the Network Mapper plugin enabled.</p>';
                return;
            }

            addLog(`Rendering graph: ${graphData.nodes.length} nodes, ${graphData.edges.length} edges`, 'info');

            // Prepare nodes for vis.js ‚Äî scale sizes to avoid overlap
            const maxSize = Math.max(...graphData.nodes.map(n => n.size || 1));
            const nodeCount = graphData.nodes.length;

            // Device type color map
            const deviceColors = {
                'domain_controller': '#E91E63',
                'dns_server': '#00BCD4',
                'web_server': '#FF5722',
                'database_server': '#9C27B0',
                'mail_server': '#3F51B5',
                'file_server': '#3F51B5',
                'dhcp_server': '#009688',
                'ssh_server': '#795548',
                'vpn_gateway': '#FF9800',
                'print_server': '#607D8B',
                'syslog_server': '#8BC34A',
                'monitoring': '#CDDC39',
                'workstation': '#607D8B',
                'gateway': '#FF9800',
                'iot_device': '#9E9E9E',
            };

            // Device type shapes
            const deviceShapes = {
                'domain_controller': 'diamond',
                'dns_server': 'triangle',
                'web_server': 'square',
                'database_server': 'star',
                'gateway': 'triangleDown',
            };

            const nodes = graphData.nodes.map(node => {
                let color = node.group === 'internal' ? '#4CAF50' : '#f44336';
                let shape = 'dot';

                // Scale node size: smaller when many nodes, larger when few
                const rawSize = node.size || 1;
                const scaled = 5 + (rawSize / Math.max(maxSize, 1)) * 20;

                // Color by device type if profiled, otherwise by role/group
                if (node.device_type && deviceColors[node.device_type]) {
                    color = deviceColors[node.device_type];
                    shape = deviceShapes[node.device_type] || 'dot';
                } else if (node.roles && node.roles.includes('server')) {
                    color = '#FFC107';
                }

                const rolesStr = node.roles ? node.roles.join(', ') : 'none';
                const servicesStr = typeof node.services === 'number' ? `${node.services} services` : String(node.services);
                const deviceStr = node.device_label || node.device_type || '';

                // Build label: IP + device type tag
                let label = node.label;
                if (deviceStr) {
                    label = `${node.label}\n[${deviceStr}]`;
                }

                return {
                    id: node.id,
                    label: label,
                    title: `${node.label}${deviceStr ? '\nDevice: ' + deviceStr : ''}\nServices: ${servicesStr}\nRoles: ${rolesStr}`,
                    color: color,
                    shape: shape,
                    size: scaled,
                    font: { size: Math.max(8, 14 - Math.floor(nodeCount / 30)), color: '#eee', multi: 'md' }
                };
            });

            // Prepare edges for vis.js
            const edges = graphData.edges.map(edge => ({
                from: edge.from,
                to: edge.to,
                value: edge.value,
                title: edge.title || `${edge.value} connections`
            }));

            const data = { nodes: new vis.DataSet(nodes), edges: new vis.DataSet(edges) };

            // Adjust physics spacing based on node count
            const repulsion = nodeCount > 100 ? -150 : nodeCount > 50 ? -100 : -50;
            const springLen = nodeCount > 100 ? 250 : nodeCount > 50 ? 180 : 120;

            const options = {
                nodes: {
                    shape: 'dot',
                    font: { size: Math.max(8, 14 - Math.floor(nodeCount / 30)), color: '#eee' }
                },
                edges: {
                    color: { color: '#666', highlight: '#667eea' },
                    smooth: { type: 'continuous' }
                },
                physics: {
                    enabled: true,
                    solver: 'forceAtlas2Based',
                    forceAtlas2Based: {
                        gravitationalConstant: repulsion,
                        centralGravity: 0.005,
                        springLength: springLen,
                        springConstant: 0.04,
                        avoidOverlap: 0.8
                    },
                    stabilization: {
                        enabled: true,
                        iterations: 300,
                        updateInterval: 25,
                        fit: true
                    },
                    maxVelocity: 50,
                    minVelocity: 0.75,
                },
                interaction: {
                    hover: true,
                    tooltipDelay: 200,
                    zoomView: true
                }
            };

            // Destroy previous graph if it exists to avoid lingering timers
            if (networkGraph) {
                networkGraph.destroy();
                networkGraph = null;
            }

            networkGraph = new vis.Network(container, data, options);
            networkGraphData = { nodes: data.nodes, edges: data.edges, raw: graphData };

            // Permanently disable physics once stabilization completes
            networkGraph.once('stabilizationIterationsDone', function() {
                networkGraph.setOptions({ physics: { enabled: false } });
            });

            // Hard fallback: kill physics after 4 seconds no matter what
            const graphRef = networkGraph;
            setTimeout(() => {
                try { graphRef.setOptions({ physics: { enabled: false } }); } catch(e) {}
            }, 4000);

            // Add click handler
            networkGraph.on('click', function(params) {
                if (params.nodes.length > 0) {
                    const nodeId = params.nodes[0];
                    const node = graphData.nodes.find(n => n.id === nodeId);
                    if (node) {
                        showNodeDetails(node);
                    }
                }
            });
        }

        function showNodeDetails(node) {
            const rolesStr = node.roles ? node.roles.join(', ') : 'none';
            const servicesStr = typeof node.services === 'number' ? `${node.services} services` : String(node.services);
            const deviceStr = node.device_label || node.device_type || 'Unknown';
            alert(`${node.label}\n` +
                  `Device: ${deviceStr}\n` +
                  `Type: ${node.group}\n` +
                  `Sensor: ${node.sensor_id || 'default'}\n` +
                  `Services: ${servicesStr}\n` +
                  `Roles: ${rolesStr}`);
        }

        async function loadNetworkSummary() {
            try {
                const response = await fetch('/api/network-summary');
                const summary = await response.json();

                if (summary.error) {
                    return;
                }

                // Device type display names and icons
                const deviceLabels = {
                    'domain_controller': { label: 'Domain Controllers', icon: 'üè∞' },
                    'dns_server': { label: 'DNS Servers', icon: 'üåê' },
                    'gateway': { label: 'Gateways / Firewalls', icon: 'üõ°' },
                    'vpn_gateway': { label: 'VPN Gateways', icon: 'üîí' },
                    'web_server': { label: 'Web Servers', icon: 'üåç' },
                    'database_server': { label: 'Database Servers', icon: 'üóÑ' },
                    'file_server': { label: 'File Servers', icon: 'üìÅ' },
                    'mail_server': { label: 'Mail Servers', icon: 'üìß' },
                    'dhcp_server': { label: 'DHCP Servers', icon: 'üì°' },
                    'ssh_server': { label: 'SSH Servers', icon: 'üîë' },
                    'syslog_server': { label: 'Syslog / SIEM', icon: 'üìã' },
                    'monitoring': { label: 'Monitoring Systems', icon: 'üìä' },
                    'print_server': { label: 'Printers', icon: 'üñ®' },
                    'workstation': { label: 'Workstations', icon: 'üíª' },
                    'iot_device': { label: 'IoT Devices', icon: 'üì±' },
                };

                let html = `
                    <div style="display:grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap:10px; margin-bottom:20px;">
                        <div style="background:var(--bg-tertiary); padding:10px; border-radius:5px; text-align:center;">
                            <div style="font-size:20px; font-weight:700;">${summary.total_nodes}</div>
                            <div style="font-size:11px; opacity:0.7;">Total Nodes</div>
                        </div>
                        <div style="background:var(--bg-tertiary); padding:10px; border-radius:5px; text-align:center;">
                            <div style="font-size:20px; font-weight:700;">${summary.internal_nodes}</div>
                            <div style="font-size:11px; opacity:0.7;">Internal</div>
                        </div>
                        <div style="background:var(--bg-tertiary); padding:10px; border-radius:5px; text-align:center;">
                            <div style="font-size:20px; font-weight:700;">${summary.external_nodes}</div>
                            <div style="font-size:11px; opacity:0.7;">External</div>
                        </div>
                        <div style="background:var(--bg-tertiary); padding:10px; border-radius:5px; text-align:center;">
                            <div style="font-size:20px; font-weight:700;">${summary.profiled || 0}</div>
                            <div style="font-size:11px; opacity:0.7;">Profiled</div>
                        </div>
                        <div style="background:var(--bg-tertiary); padding:10px; border-radius:5px; text-align:center;">
                            <div style="font-size:20px; font-weight:700;">${summary.total_services}</div>
                            <div style="font-size:11px; opacity:0.7;">Services</div>
                        </div>
                    </div>
                `;

                // Device inventory sections
                const inventory = summary.device_inventory || {};
                if (Object.keys(inventory).length > 0) {
                    html += '<h4 style="margin:15px 0 10px 0;">Device Inventory</h4>';

                    for (const [dtype, devices] of Object.entries(inventory)) {
                        const info = deviceLabels[dtype] || { label: dtype, icon: '‚ùì' };
                        html += `
                            <details style="margin-bottom:8px; background:var(--bg-tertiary); border-radius:5px; padding:0;">
                                <summary style="cursor:pointer; padding:10px 14px; font-weight:600; display:flex; justify-content:space-between; align-items:center;">
                                    <span>${info.icon} ${info.label}</span>
                                    <span style="background:var(--accent); color:#fff; padding:2px 10px; border-radius:10px; font-size:12px;">${devices.length}</span>
                                </summary>
                                <div style="padding:0 14px 10px 14px;">
                                    <table style="width:100%; font-size:13px; border-collapse:collapse;">
                                        <tr style="opacity:0.7; font-size:11px; text-transform:uppercase;">
                                            <td style="padding:4px 8px;">IP Address</td>
                                            <td style="padding:4px 8px;">Hostname</td>
                                            <td style="padding:4px 8px;">Services</td>
                                            <td style="padding:4px 8px; text-align:right;">Connections</td>
                                        </tr>
                                        ${devices.map(d => `
                                            <tr style="border-top:1px solid rgba(255,255,255,0.05);">
                                                <td style="padding:4px 8px; font-family:monospace; cursor:pointer;" onclick="document.getElementById('graph-search').value='${d.ip}'; searchGraphNode();">${d.ip}</td>
                                                <td style="padding:4px 8px; opacity:0.8; max-width:200px; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;">${d.hostnames.length > 0 ? d.hostnames[0] : '-'}</td>
                                                <td style="padding:4px 8px; opacity:0.7; font-size:11px;">${d.services.slice(0, 5).join(', ') || '-'}</td>
                                                <td style="padding:4px 8px; text-align:right;">${d.connections.toLocaleString()}</td>
                                            </tr>
                                        `).join('')}
                                    </table>
                                </div>
                            </details>
                        `;
                    }
                } else {
                    html += '<p style="opacity:0.6; margin-top:10px;">No devices profiled yet. Click <strong>Profile Devices</strong> above to classify network hosts.</p>';
                }

                // Top talkers section
                if (summary.top_talkers && summary.top_talkers.length > 0) {
                    html += '<h4 style="margin:15px 0 10px 0;">Top Talkers</h4>';
                    html += '<table style="width:100%; font-size:13px; border-collapse:collapse;">';
                    summary.top_talkers.forEach(t => {
                        html += `
                            <tr style="border-top:1px solid rgba(255,255,255,0.05);">
                                <td style="padding:4px 8px; font-family:monospace; cursor:pointer;" onclick="document.getElementById('graph-search').value='${t.ip}'; searchGraphNode();">${t.ip}</td>
                                <td style="padding:4px 8px; text-align:right;">${t.connections.toLocaleString()} conns</td>
                                <td style="padding:4px 8px; opacity:0.6;">${t.sensor_id}</td>
                            </tr>
                        `;
                    });
                    html += '</table>';
                }

                document.getElementById('network-summary').innerHTML = html;

            } catch (error) {
                console.error('Error loading network summary:', error);
            }
        }

        function resetGraphZoom() {
            if (networkGraph) {
                networkGraph.fit();
            }
        }

        function exportGraphImage() {
            if (networkGraph) {
                const canvas = document.querySelector('#network-graph canvas');
                if (canvas) {
                    const url = canvas.toDataURL('image/png');
                    const link = document.createElement('a');
                    link.download = 'network-graph.png';
                    link.href = url;
                    link.click();
                    addLog('Exported network graph as PNG', 'info');
                }
            }
        }

        function searchGraphNode() {
            const query = document.getElementById('graph-search').value.trim().toLowerCase();
            if (!query || !networkGraph || !networkGraphData) return;

            // Stop physics so the node doesn't drift after focusing
            networkGraph.setOptions({ physics: { enabled: false } });

            // Search through nodes for IP match (partial match on label, id, device type)
            const matches = networkGraphData.raw.nodes.filter(n => {
                const lbl = (n.label || '').toLowerCase();
                const nid = (n.id || '').toLowerCase();
                const dtype = (n.device_type || '').toLowerCase();
                const dlabel = (n.device_label || '').toLowerCase();
                return lbl.includes(query) || nid.includes(query) ||
                       dtype.includes(query) || dlabel.includes(query);
            });

            if (matches.length === 0) {
                addLog(`No node found matching "${query}"`, 'warning');
                return;
            }

            const match = matches[0];
            addLog(`Found: ${match.label}${match.device_label ? ' [' + match.device_label + ']' : ''} (${matches.length} match${matches.length > 1 ? 'es' : ''})`, 'info');

            // Highlight the node with a distinct border
            networkGraph.selectNodes([match.id]);
            networkGraph.focus(match.id, {
                scale: 1.5,
                animation: { duration: 500, easingFunction: 'easeInOutQuad' }
            });
        }

        function changeGraphLayout() {
            const layout = document.getElementById('graph-layout').value;
            if (networkGraph) {
                // Briefly enable physics with new solver to re-layout, then stop
                networkGraph.setOptions({
                    physics: {
                        enabled: true,
                        solver: layout,
                        stabilization: { enabled: true, iterations: 200 }
                    }
                });
                networkGraph.once('stabilizationIterationsDone', function() {
                    networkGraph.setOptions({ physics: { enabled: false } });
                });
                // Hard fallback
                const ref = networkGraph;
                setTimeout(() => {
                    try { ref.setOptions({ physics: { enabled: false } }); } catch(e) {}
                }, 4000);
            }
        }

        async function profileDevices() {
            const btn = document.getElementById('profile-btn');
            const statusDiv = document.getElementById('profile-status');
            const timeRange = document.getElementById('profile-time-range').value;

            btn.disabled = true;
            btn.textContent = 'Profiling...';
            statusDiv.style.display = 'block';
            statusDiv.innerHTML = 'Querying Splunk zeek:conn logs to classify devices... This may take a minute.';
            addLog(`Starting device profiling (${timeRange})...`, 'info');

            try {
                const response = await fetch('/api/network-graph/profile', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ time_range: timeRange })
                });

                const result = await response.json();

                if (result.error) {
                    statusDiv.innerHTML = `<span style="color:#f44336;">Error: ${result.error}</span>`;
                    addLog(`Device profiling failed: ${result.error}`, 'error');
                    return;
                }

                // Show results
                const types = result.device_types || {};
                const typeList = Object.entries(types)
                    .sort((a, b) => b[1] - a[1])
                    .map(([type, count]) => `<strong>${type}</strong>: ${count}`)
                    .join(' | ');

                statusDiv.innerHTML = `
                    Profiled <strong>${result.classified}</strong> / ${result.total_internal} internal devices.
                    ${result.unclassified} unclassified.<br>
                    <span style="font-size:13px; opacity:0.8;">${typeList}</span>
                `;

                addLog(`Device profiling complete: ${result.classified} devices classified`, 'info');

                // Refresh the graph to show new labels
                loadNetworkGraph();

            } catch (error) {
                statusDiv.innerHTML = `<span style="color:#f44336;">Error: ${error.message}</span>`;
                addLog(`Device profiling error: ${error.message}`, 'error');
            } finally {
                btn.disabled = false;
                btn.textContent = 'Profile Devices';
            }
        }

        async function startHunt(e) {
            e.preventDefault();

            const timeRange = document.getElementById('time-range').value;
            const mode = document.getElementById('hunt-mode').value;
            const description = document.getElementById('description').value;

            try {
                const response = await fetch('/api/hunt', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ time_range: timeRange, mode, description })
                });

                const data = await response.json();
                currentHuntId = data.hunt_id;
                localStorage.setItem('currentHuntId', currentHuntId);

                // Show progress
                document.getElementById('progress').classList.add('active');
                addLog(`Started hunt: ${currentHuntId}`, 'info');

            } catch (error) {
                console.error('Error starting hunt:', error);
                addLog(`Error starting hunt: ${error.message}`, 'error');
            }
        }

        function quickHunt(timeRange) {
            document.getElementById('time-range').value = timeRange;
            showTab('new-hunt');
            setTimeout(() => document.getElementById('hunt-form').dispatchEvent(new Event('submit')), 100);
        }

        // All query type labels
        const QUERY_LABELS = {
            'network_connections': 'Network Connections',
            'dns_queries': 'DNS Queries',
            'authentication_logs': 'Auth Logs',
            'process_logs': 'Process Logs',
            'powershell_logs': 'PowerShell',
            'file_operations': 'File Ops',
            'scheduled_tasks': 'Scheduled Tasks',
            'registry_changes': 'Registry Changes',
        };

        function handleProgress(data) {
            if (!data.stage) return;

            const progressFill = document.getElementById('progress-fill');
            const progressMessage = document.getElementById('progress-message');
            const collectionDetail = document.getElementById('collection-detail');
            const progressTitle = document.getElementById('progress-title');

            progressFill.style.width = `${data.progress}%`;
            progressFill.textContent = `${data.progress}%`;
            progressMessage.textContent = data.message;

            addLog(data.message, data.stage === 'error' ? 'error' : 'info');

            // Show detailed collection stats
            if (data.stage === 'collect' && data.collection) {
                collectionDetail.style.display = 'block';
                progressTitle.textContent = 'Collecting Data from Splunk...';

                const c = data.collection;

                // Update stat boxes
                document.getElementById('coll-total-events').textContent =
                    (c.total_events || 0).toLocaleString();
                document.getElementById('coll-queries-done').textContent =
                    `${c.queries_done || 0} / ${c.queries_total || 8}`;

                if (c.total_windows && c.total_windows > 1) {
                    document.getElementById('coll-window').textContent =
                        `${c.window || 0} / ${c.total_windows}`;
                } else {
                    document.getElementById('coll-window').textContent = '1 / 1';
                }

                if (c.elapsed_seconds) {
                    const mins = Math.floor(c.elapsed_seconds / 60);
                    const secs = Math.floor(c.elapsed_seconds % 60);
                    document.getElementById('coll-elapsed').textContent =
                        mins > 0 ? `${mins}m ${secs}s` : `${secs}s`;
                }

                // Mark total events green when queries are all done
                if (c.queries_done >= (c.queries_total || 8)) {
                    document.getElementById('coll-total-events').classList.add('done');
                    document.getElementById('coll-queries-done').classList.add('done');
                }

                // Update per-query tracker chips
                if (c.events_by_type) {
                    const tracker = document.getElementById('query-tracker');
                    tracker.innerHTML = '';
                    for (const [key, label] of Object.entries(QUERY_LABELS)) {
                        const count = c.events_by_type[key];
                        const isDone = count !== undefined;
                        const chip = document.createElement('div');
                        chip.className = `query-chip${isDone ? ' done' : ''}`;
                        chip.innerHTML = `
                            <span class="q-name">${label}</span>
                            <span class="q-count">${isDone ? count.toLocaleString() : '...'}</span>
                        `;
                        tracker.appendChild(chip);
                    }
                }
            } else if (data.stage === 'analyze' || data.stage === 'hunt') {
                progressTitle.textContent = data.stage === 'analyze'
                    ? 'Analyzing Collected Data...'
                    : 'Running Hunting Agents...';
                // Start live network graph refresh during analysis
                startLiveGraph();
            } else if (data.stage === 'finalize') {
                progressTitle.textContent = 'Finalizing Results...';
            }

            // Error handling
            if (data.stage === 'error' && data.error_detail) {
                progressTitle.textContent = 'Hunt Failed';
                addLog('Error details:', 'error');
                data.error_detail.split('\n').forEach(line => {
                    if (line.trim()) addLog(line, 'error');
                });
            }

            if (data.stage === 'complete') {
                progressTitle.textContent = 'Hunt Complete!';
                currentHuntId = null;
                localStorage.removeItem('currentHuntId');
                stopLiveGraph();
                setTimeout(() => {
                    document.getElementById('progress').classList.remove('active');
                    collectionDetail.style.display = 'none';
                    progressFill.style.width = '0%';
                    // Reset stat classes
                    document.getElementById('coll-total-events').classList.remove('done');
                    document.getElementById('coll-queries-done').classList.remove('done');
                    loadRecentHunts();
                    loadStats();
                    viewHuntDetails(data.hunt_id);
                }, 2000);
            } else if (data.stage === 'error') {
                currentHuntId = null;
                localStorage.removeItem('currentHuntId');
                stopLiveGraph();
                setTimeout(() => {
                    document.getElementById('progress').classList.remove('active');
                    collectionDetail.style.display = 'none';
                    progressFill.style.width = '0%';
                    loadRecentHunts();
                    loadStats();
                }, 5000);
            }
        }

        async function loadPlugins() {
            try {
                const response = await fetch('/api/plugins');
                const plugins = await response.json();

                const pluginList = document.getElementById('plugin-list');
                pluginList.innerHTML = '';

                if (plugins.length === 0) {
                    pluginList.innerHTML = '<p>No plugins registered yet.</p>';
                    return;
                }

                plugins.forEach(plugin => {
                    const div = document.createElement('div');
                    div.className = 'plugin-card';
                    const statsHtml = plugin.rules_loaded != null
                        ? `<p style="color:#667eea; font-size:13px; margin-top:8px;">${plugin.rules_loaded.toLocaleString()} rules loaded</p>`
                        : '';
                    div.innerHTML = `
                        <h3>${plugin.name}</h3>
                        <p>${plugin.description}</p>
                        ${statsHtml}
                        <span class="plugin-status ${plugin.enabled ? 'plugin-enabled' : 'plugin-disabled'}">
                            ${plugin.enabled ? 'Enabled' : 'Disabled'}
                        </span>
                        <button class="btn btn-secondary" onclick="togglePlugin('${plugin.name}', ${!plugin.enabled})" style="margin-top:10px;">
                            ${plugin.enabled ? 'Disable' : 'Enable'}
                        </button>
                    `;
                    pluginList.appendChild(div);
                });

            } catch (error) {
                console.error('Error loading plugins:', error);
            }
        }

        async function togglePlugin(name, enable) {
            try {
                const endpoint = enable ? 'enable' : 'disable';
                const response = await fetch(`/api/plugins/${name}/${endpoint}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ name, enabled: enable, config: {} })
                });

                if (!response.ok) {
                    const err = await response.json();
                    addLog(`Failed to ${endpoint} plugin: ${err.error || 'Unknown error'}`, 'error');
                    return;
                }

                addLog(`Plugin ${name} ${enable ? 'enabled' : 'disabled'}`, 'info');
                await loadPlugins();
                await loadStats();

            } catch (error) {
                console.error('Error toggling plugin:', error);
                addLog(`Error toggling plugin: ${error.message}`, 'error');
            }
        }

        function showTab(tabName) {
            // Hide all tabs
            document.querySelectorAll('.tab-content').forEach(tab => {
                tab.classList.remove('active');
            });

            // Remove active from all tab buttons
            document.querySelectorAll('.tab').forEach(btn => {
                btn.classList.remove('active');
            });

            // Show selected tab
            document.getElementById(tabName).classList.add('active');

            // Highlight active tab button ‚Äî use event.target if called from onclick,
            // otherwise find matching button by tab name
            if (typeof event !== 'undefined' && event && event.target && event.target.classList) {
                event.target.classList.add('active');
            } else {
                const tabKey = tabName.split('-')[0];
                document.querySelectorAll('.tab').forEach(btn => {
                    if (btn.textContent.toLowerCase().includes(tabKey)) {
                        btn.classList.add('active');
                    }
                });
            }
        }

        // ========================================
        // Network Maps Management
        // ========================================

        async function loadNetworkMaps() {
            try {
                const response = await fetch('/api/network-maps');
                const maps = await response.json();

                const list = document.getElementById('network-maps-list');
                list.innerHTML = '';

                if (maps.length === 0) {
                    list.innerHTML = '<li style="padding:15px;opacity:0.7;">No network maps saved yet. Run a hunt with the Network Mapper plugin enabled.</li>';
                    return;
                }

                maps.forEach(map => {
                    const li = document.createElement('li');
                    li.className = `map-item${map.is_current ? ' current' : ''}`;

                    const sizeKB = (map.size_bytes / 1024).toFixed(1);
                    const sizeMB = (map.size_bytes / (1024 * 1024)).toFixed(1);
                    const sizeStr = map.size_bytes > 1024 * 1024 ? `${sizeMB} MB` : `${sizeKB} KB`;

                    const ts = map.timestamp ? new Date(map.timestamp).toLocaleString() : 'Unknown';

                    li.innerHTML = `
                        <div class="map-info">
                            <strong>${map.filename}</strong>
                            ${map.is_current ? '<span style="color:var(--success); margin-left:8px;">(Active)</span>' : ''}
                            <div style="margin-top:4px; opacity:0.7; font-size:13px;">
                                ${map.total_nodes.toLocaleString()} nodes |
                                ${map.sensors.length} sensor(s) |
                                ${sizeStr} |
                                ${ts}
                            </div>
                        </div>
                        <div class="map-actions">
                            ${!map.is_current ? `<button class="btn btn-sm" onclick="loadNetworkMapFile('${map.filename}')">Load</button>` : ''}
                            ${!map.is_current ? `<button class="btn btn-danger btn-sm" onclick="deleteNetworkMap('${map.filename}')">Delete</button>` : ''}
                        </div>
                    `;

                    list.appendChild(li);
                });

            } catch (error) {
                console.error('Error loading network maps:', error);
                addLog(`Error loading maps: ${error.message}`, 'error');
            }
        }

        async function saveMapSnapshot() {
            const name = prompt('Enter snapshot name (leave blank for auto-timestamp):');
            if (name === null) return;  // cancelled

            try {
                const url = name ? `/api/network-maps/snapshot?name=${encodeURIComponent(name)}` : '/api/network-maps/snapshot';
                const response = await fetch(url, { method: 'POST' });
                const result = await response.json();

                if (result.error) {
                    alert(result.error);
                    return;
                }

                addLog(`Saved map snapshot: ${result.filename}`, 'info');
                loadNetworkMaps();

            } catch (error) {
                console.error('Error saving snapshot:', error);
                addLog(`Error saving snapshot: ${error.message}`, 'error');
            }
        }

        async function loadNetworkMapFile(filename) {
            if (!confirm(`Load "${filename}"? This will replace the current active map.`)) return;

            try {
                const response = await fetch(`/api/network-maps/${encodeURIComponent(filename)}/load`, { method: 'POST' });
                const result = await response.json();

                if (result.error) {
                    alert(result.error);
                    return;
                }

                addLog(`Loaded map: ${filename} (${result.total_nodes.toLocaleString()} nodes)`, 'info');
                loadNetworkMaps();

            } catch (error) {
                console.error('Error loading map:', error);
                addLog(`Error loading map: ${error.message}`, 'error');
            }
        }

        async function deleteNetworkMap(filename) {
            if (!confirm(`Delete "${filename}"? This cannot be undone.`)) return;

            try {
                const response = await fetch(`/api/network-maps/${encodeURIComponent(filename)}`, { method: 'DELETE' });
                const result = await response.json();

                if (result.error) {
                    alert(result.error);
                    return;
                }

                addLog(`Deleted map: ${filename}`, 'info');
                loadNetworkMaps();

            } catch (error) {
                console.error('Error deleting map:', error);
                addLog(`Error deleting map: ${error.message}`, 'error');
            }
        }

        async function resetNetworkMap() {
            if (!confirm('Reset the network map? All current map data will be cleared. Consider saving a snapshot first.')) return;

            try {
                const response = await fetch('/api/network-maps/reset', { method: 'POST' });
                const result = await response.json();

                if (result.error) {
                    alert(result.error);
                    return;
                }

                addLog('Network map reset to empty', 'info');
                loadNetworkMaps();

            } catch (error) {
                console.error('Error resetting map:', error);
                addLog(`Error resetting map: ${error.message}`, 'error');
            }
        }

        // ========================================
        // Sigma Rule Engine
        // ========================================

        let allSigmaRules = [];
        const SIGMA_PAGE_SIZE = 50;

        async function loadSigmaRules() {
            try {
                const response = await fetch('/api/sigma/rules');
                const data = await response.json();

                if (data.error) {
                    document.getElementById('sigma-rules-list').innerHTML =
                        `<p style="opacity:0.7;">${data.error}. Enable it in the Plugins tab.</p>`;
                    return;
                }

                allSigmaRules = Array.isArray(data) ? data : [];
                document.getElementById('sigma-stat-rules').textContent = allSigmaRules.length;

                renderSigmaRules(allSigmaRules);
                loadSigmaResults();

            } catch (error) {
                console.error('Error loading Sigma rules:', error);
            }
        }

        function filterSigmaRules() {
            const query = document.getElementById('sigma-search').value.toLowerCase();
            const level = document.getElementById('sigma-level-filter').value;

            const filtered = allSigmaRules.filter(rule => {
                const matchesQuery = !query ||
                    rule.title.toLowerCase().includes(query) ||
                    (rule.description || '').toLowerCase().includes(query) ||
                    (rule.category || '').toLowerCase().includes(query) ||
                    (rule.author || '').toLowerCase().includes(query) ||
                    (rule.mitre_techniques || []).some(t => t.toLowerCase().includes(query)) ||
                    (rule.mitre_tactics || []).some(t => t.toLowerCase().includes(query));
                const matchesLevel = !level || rule.level === level;
                return matchesQuery && matchesLevel;
            });

            renderSigmaRules(filtered);
        }

        function renderSigmaRules(rules, limit = SIGMA_PAGE_SIZE) {
            const container = document.getElementById('sigma-rules-list');
            container.innerHTML = '';

            if (rules.length === 0) {
                container.innerHTML = '<p style="opacity:0.7;">No rules match the current filter.</p>';
                return;
            }

            const showing = rules.slice(0, limit);

            showing.forEach(rule => {
                const div = document.createElement('div');
                div.className = `sigma-rule-item level-${rule.level}`;
                const techniques = (rule.mitre_techniques || []).map(t =>
                    `<span class="sigma-tag">${t}</span>`
                ).join('');
                const tactics = (rule.mitre_tactics || []).map(t =>
                    `<span class="sigma-tag">${t}</span>`
                ).join('');

                div.innerHTML = `
                    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;">
                        <strong>${rule.title}</strong>
                        <span class="sigma-badge ${rule.level}">${rule.level}</span>
                    </div>
                    <p style="opacity:0.8; font-size:13px; margin-bottom:6px;">${rule.description || ''}</p>
                    <div style="font-size:12px; opacity:0.7;">
                        Category: <strong>${rule.category}</strong> |
                        Data: <strong>${rule.data_type}</strong> |
                        Author: ${rule.author || 'Unknown'}
                    </div>
                    ${techniques || tactics ? `<div style="margin-top:6px;">${tactics}${techniques}</div>` : ''}
                `;
                container.appendChild(div);
            });

            if (rules.length > limit) {
                const more = document.createElement('button');
                more.className = 'btn btn-secondary';
                more.style.cssText = 'margin-top:15px; width:100%;';
                more.textContent = `Show More (${limit} of ${rules.length})`;
                more.onclick = () => renderSigmaRules(rules, limit + SIGMA_PAGE_SIZE);
                container.appendChild(more);
            }
        }

        async function loadSigmaResults() {
            try {
                const response = await fetch('/api/sigma/results');
                const data = await response.json();

                if (data.error) return;

                const matches = data.matches || [];
                const totalMatches = data.total_matches || 0;

                document.getElementById('sigma-stat-matches').textContent = totalMatches;

                const critHigh = matches.filter(m => m.level === 'critical' || m.level === 'high').length;
                document.getElementById('sigma-stat-critical').textContent = critHigh;

                const card = document.getElementById('sigma-results-card');
                const list = document.getElementById('sigma-results-list');
                const meta = document.getElementById('sigma-results-meta');

                card.style.display = 'block';

                if (matches.length === 0) {
                    meta.textContent = data.timestamp
                        ? `Last scan: ${new Date(data.timestamp).toLocaleString()} | ${data.rules_checked || 0}/${data.total_rules || 0} rules checked | No matches`
                        : 'No scan results yet. Run a hunt with the Sigma Engine plugin enabled.';
                    list.innerHTML = '<p style="text-align:center; padding:20px; opacity:0.6;">No Sigma rule matches found in the latest scan.</p>';
                    return;
                }

                meta.textContent = `Scan: ${data.timestamp ? new Date(data.timestamp).toLocaleString() : 'Unknown'} | ${data.rules_checked || 0}/${data.total_rules || 0} rules checked | ${totalMatches} total matches`;

                list.innerHTML = '';
                matches.forEach(match => {
                    const div = document.createElement('div');
                    div.className = `sigma-match-item level-${match.level}`;

                    const techniques = (match.mitre_techniques || []).map(t =>
                        `<span class="sigma-tag">${t}</span>`
                    ).join('');

                    const sampleHtml = (match.sample_events || []).slice(0, 2).map(ev =>
                        `<div class="sample-event">${escapeHtml(JSON.stringify(ev, null, 2).substring(0, 500))}</div>`
                    ).join('');

                    div.innerHTML = `
                        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;">
                            <strong>${match.rule_title}</strong>
                            <div>
                                <span class="sigma-badge ${match.level}">${match.level}</span>
                                <span style="font-weight:700; margin-left:8px;">${match.match_count} hit${match.match_count > 1 ? 's' : ''}</span>
                            </div>
                        </div>
                        <p style="opacity:0.8; font-size:13px;">${match.rule_description || ''}</p>
                        <div style="font-size:12px; opacity:0.7; margin-top:4px;">
                            Data: <strong>${match.data_type}</strong> ${techniques}
                        </div>
                        ${sampleHtml ? `<details style="margin-top:8px;"><summary style="cursor:pointer; font-size:12px;">Sample events</summary>${sampleHtml}</details>` : ''}
                    `;
                    list.appendChild(div);
                });

            } catch (error) {
                console.error('Error loading Sigma results:', error);
            }
        }

        async function reloadSigmaRules() {
            try {
                const response = await fetch('/api/sigma/reload', { method: 'POST' });
                const result = await response.json();

                if (result.error) {
                    alert(result.error);
                    return;
                }

                addLog(`Sigma rules reloaded: ${result.rules_count} rules`, 'info');
                loadSigmaRules();

            } catch (error) {
                console.error('Error reloading Sigma rules:', error);
                addLog(`Error reloading Sigma rules: ${error.message}`, 'error');
            }
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // ========================================
        // GeoIP Map
        // ========================================

        async function loadGeoIPMap() {
            try {
                const response = await fetch('/api/geoip/map');
                const data = await response.json();

                if (data.error) {
                    document.getElementById('geoip-map').innerHTML =
                        `<p style="text-align:center; padding:50px;">${data.error}. Enable it in the Plugins tab.</p>`;
                    return;
                }

                renderGeoIPMap(data);
                renderCountryChart(data.country_summary || {});
                renderTopTalkers(data.top_talkers || []);

                addLog(`GeoIP: Loaded ${(data.locations || []).length} locations across ${Object.keys(data.country_summary || {}).length} countries`, 'info');

            } catch (error) {
                console.error('Error loading GeoIP map:', error);
                addLog(`Error loading GeoIP map: ${error.message}`, 'error');
            }
        }

        function renderGeoIPMap(data) {
            const container = document.getElementById('geoip-map');
            const locations = data.locations || [];

            if (locations.length === 0) {
                container.innerHTML = '<p style="text-align:center; padding:50px;">No external IP data yet. Run a hunt with the GeoIP Mapper plugin enabled.</p>';
                return;
            }

            // Initialize or reset Leaflet map
            if (geoipMap) {
                geoipMap.remove();
            }

            geoipMap = L.map('geoip-map', {
                center: [20, 0],
                zoom: 2,
                minZoom: 2,
                maxZoom: 12
            });

            L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
                attribution: '&copy; OSM &copy; CARTO',
                maxZoom: 19
            }).addTo(geoipMap);

            // Find max connections for scaling
            const maxConn = Math.max(...locations.map(l => l.connection_count), 1);

            locations.forEach(loc => {
                if (!loc.lat || !loc.lon) return;

                // Scale radius by connection count (4-20px)
                const radius = Math.max(4, Math.min(20, (loc.connection_count / maxConn) * 20));

                // Color by connection density
                let color = '#667eea';
                if (loc.connection_count > maxConn * 0.5) color = '#dc3545';
                else if (loc.connection_count > maxConn * 0.1) color = '#ff6b35';
                else if (loc.connection_count > maxConn * 0.01) color = '#ffc107';

                const marker = L.circleMarker([loc.lat, loc.lon], {
                    radius: radius,
                    fillColor: color,
                    color: '#fff',
                    weight: 1,
                    opacity: 0.9,
                    fillOpacity: 0.7
                }).addTo(geoipMap);

                const services = (loc.services || []).slice(0, 10).join(', ');
                marker.bindPopup(
                    `<strong>${loc.ip}</strong><br>` +
                    `${loc.city ? loc.city + ', ' : ''}${loc.country}<br>` +
                    `Connections: <strong>${loc.connection_count.toLocaleString()}</strong><br>` +
                    `${loc.org ? 'Org: ' + loc.org + '<br>' : ''}` +
                    `${loc.isp ? 'ISP: ' + loc.isp + '<br>' : ''}` +
                    `${services ? 'Ports: ' + services : ''}`
                );
            });
        }

        function renderCountryChart(countrySummary) {
            const container = document.getElementById('geoip-country-chart');
            const entries = Object.entries(countrySummary).sort((a, b) => b[1] - a[1]).slice(0, 15);

            if (entries.length === 0) {
                container.innerHTML = '<p style="opacity:0.7;">No data</p>';
                return;
            }

            const maxCount = entries[0][1];
            container.innerHTML = entries.map(([country, count]) => {
                const pct = (count / maxCount * 100).toFixed(0);
                return `
                    <div class="country-bar">
                        <span class="bar-label">${country}</span>
                        <div class="bar-fill" style="width:${pct}%; flex:1; max-width:calc(100% - 200px);"></div>
                        <span class="bar-count">${count.toLocaleString()}</span>
                    </div>
                `;
            }).join('');
        }

        function renderTopTalkers(talkers) {
            const container = document.getElementById('geoip-top-talkers');

            if (talkers.length === 0) {
                container.innerHTML = '<p style="opacity:0.7;">No data</p>';
                return;
            }

            container.innerHTML = talkers.slice(0, 15).map(t => `
                <div class="geoip-top-talker">
                    <span>
                        <strong>${t.ip}</strong>
                        <span style="opacity:0.7; margin-left:8px;">${t.city ? t.city + ', ' : ''}${t.country}</span>
                    </span>
                    <span>
                        <strong>${t.connections.toLocaleString()}</strong> conn
                        ${t.org ? `<span style="opacity:0.6; margin-left:6px;">${t.org}</span>` : ''}
                    </span>
                </div>
            `).join('');
        }

        function addLog(message, type = 'info') {
            const logOutput = document.getElementById('log-output');
            const timestamp = new Date().toLocaleTimeString();
            const logClass = `log-${type}`;

            const logLine = document.createElement('div');
            logLine.className = `log-line ${logClass}`;
            logLine.textContent = `[${timestamp}] ${message}`;

            logOutput.appendChild(logLine);
            logOutput.scrollTop = logOutput.scrollHeight;

            // Keep only last 100 logs
            while (logOutput.children.length > 100) {
                logOutput.removeChild(logOutput.firstChild);
            }
        }
    </script>
</body>
</html>
